[[hsm-ng-guide]]
= HSM NG

[[hierarchical-storage-management]]
Hierarchical Storage Management
-------------------------------

[[the-hierarchical-storage-management-technique]]
The Hierarchical Storage Management technique
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

HSM is a data storage technique that moves data between different stores
according to a defined policy.

The most common use of such technique is the move of `older` data from a
faster-but-expensive storage device to a slower-but-cheaper one on the
following premises:

* Fast storage costs more.
* Slow storage costs less.
* `Old` data will be accessed much less frequently than `new` data.

Thus said, the advantages of the HSM technique are clear: Lowering the
overall storage cost, since only a small part of your data needs to be
on a costly storage, improving the overall user experience.

[[stores-volumes-and-policies]]
Stores, Volumes and Policies
++++++++++++++++++++++++++++

Dealing with the HSM technicque requires a clear understanding of some
related terms:

* Primary Store: The `fast-but-expensive` store where all your data
is initially placed
** Secondary Store: The `slow-but-cheap` store where `older` data will
be moved

[[zimbra-stores]]
Zimbra Stores
-------------

[[the-basics-types-of-stores-and-their-uses]]
The Basics: types of stores and their uses
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Zimbra allows for *two* different types of stores to be used:

* *Index Store*: A store that contains informations about your data used
by Apache Lucene to provide indexing and search functions.
* *Data Store*: A store that contains all your Zimbra data organized in
a MySql database

You can have multiple stores of each kind, but only one Index Store, one
Primary Data Store and one Secondary Data Store can be set as `Current`
(meaning that is currently used by Zimbra).

[[primary-and-secondary-data-stores]]
Primary and Secondary Data Stores
+++++++++++++++++++++++++++++++++

A Data Store in Zimbra can be either a Primary Data Store or a Secondary
Data Store - the meaning of `primary` and `secondary` is explained

Data is moved between the `current` Primary Data Store and the `current`
Secondary Data Store accordingly to a

[[hsm-ngmoving-items-between-stores]]
HSM NG: Moving Items between Stores
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The main feature of the HSM NG module is the ability of applying the
defined

The move can be triggered in three different ways:

* Click the `Apply Policy` button in the Administration Zimlet
* Start the doMoveBlobs operation through the CLI
* Enable the Policy Application Scheduling in the Administration Zimlet
and wait for it to start automatically

Once the move is started the following operations are performed:

* HSM NG scans through the Primary Store to see which items comply to
the defined policy
* All the Blobs of the tems found in the first step is copied to the
Secondary Store
* The database entries related to the copied items are updated to
reflect the move
* If the second and the third steps are completed successfully (and only
in this case), the old Blobs are deleted from the Primary Store

The Move operation is `stateful` - each step is executed only if the
previous ones have been completed successfully - so the risk of data
loss during a Move operation is virtually nonexistent.

[[domoveblobs]]
doMoveBlobs
-----------

[[the-domoveblobs-operation-of-hsm-ng]]
The doMoveBlobs operation of HSM NG
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The doMoveBlobs is the heart of the HSM NG Modules.

It's duty is to move items between the Current Primary Store and the
Current Secondary Store according to the proper HSM policy.

The move is performed by a transactional algorythm, so should an error
occour during one of the steps of the operation a rollback would take
place and no change will be made to the data.

Once HSM NG identifies the items to be moved, the following steps are
performed:

* Create a copy of the Blob to the Current Secondary Store.
* Update the Zimbra Database in order to notify Zimbra of the new
position of the item.
* Delete the original Blob from the Current Primary Store.

[[what-will-be-moved]]
What will be moved
++++++++++++++++++

Basically, every item that complies to the specified HSM policy.

Example:

The following policy

....
message,document:before:-20day
message:before:-10day has:attachment
....

will move all emails and documents older than 20 days along with all
emails older than 10 days and containing an attachment.

[[policy-order]]
Policy order
++++++++++++

All conditions for a policy are executed in the exact order they are
specified. HSM NG will loop on all items in the Current Primary Store
and apply each separate condition before starting the next one.

This mean that the following policies

....
message,document:before:-20day
message:before:-10day has:attachment
....

....
message:before:-10day has:attachment
message,document:before:-20day
....

applied daily on a sample server that sends/receives a total of 1000
emails per day, 100 of which containing one or more attachments, will
have the same final result while the execution time will probably be
slightly higher (or much higer, depending on the number and size of the
emails in the server).

This is because in the first policy the first condition
(message,document:before:-20day) will loop on all items, move many of
them to the Current Secondary Store, leaving less items for the second
condition to loop on.

Viceversa, having the `message:before:-10day has:attachment` as the
first condition will leave more items for the second condition to loop
on.

This is just an example and does not apply to all cases, but gives an
idea on the need to carefully plan your HSM policy.

[[executing-the-domoveblobs-operation-a.k.a.-applying-the-hsm-policy]]
Executing the doMoveBlobs operation (a.k.a. Applying the HSM policy)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

`Applying a policy` means running the `doMoveBlobs` operation in order
to move items between the Primary and Secondary store according to the
defined policy.

HSM NG gives you 3 different options to do so:

* via the Administration Zimlet
* via the CLI
* through Scheduling

[[apply-the-hsm-policy-via-the-administration-zimlet]]
Apply the HSM Policy via the Administration Zimlet
++++++++++++++++++++++++++++++++++++++++++++++++++

In order to apply the HSM Policy via the Administration Zimlet:

* Log into the Zimbra Administration Console
* Click the `HSM NG` entry on the Administration Zimlet
* Click the `Apply Policy` button

[[apply-the-hsm-policy-via-the-cli]]
Apply the HSM Policy via the CLI
++++++++++++++++++++++++++++++++

In order to apply the HSM Policy via the CLI, run the following command
as the 'zimbra' user:

` zxsuite hsm doMoveBlobs`

[[apply-the-hsm-policy-through-scheduling]]
Apply the HSM Policy through Scheduling
+++++++++++++++++++++++++++++++++++++++

In order to schedule a daily execution of the `doMoveBlobs` operation:

* Log into the Zimbra Administration Console
* Click the `HSM NG` entry on the Administration Zimlet
* Enable the scheduling by selecting the `Enable Policy Application
scheduling` button
* Select the hour to run the operation under `Policy Application
scheduled for:`

[[domoveblobs-stats-and-info]]
doMoveBlobs Stats and Info
~~~~~~~~~~~~~~~~~~~~~~~~~~

Informations about disk space savings, operation performances and more
are available by clicking the `Stats` button under the `Secondary
Volumes` list in the HSM NG tab of the Administration Zimlet.

[[volume-management]]
Volume Management
-----------------

[[zimbra-volumes]]
Zimbra Volumes
~~~~~~~~~~~~~~

A Volume is the physical representation of the notion of

[[volume-properties]]
Volume Properties
+++++++++++++++++

All Zimbra Volumes are defined by the following properties:

* Name: a unique identifier for the volume
* Path: the path where the data is going to be saved. _The Zimbra user
must have r/w permissions on this path_.
* Compression: Enable or Disable the file compression for the volume.
* Compression Threshold: the minimum file size that will trigger the
compression. 'Files under this size will never be compressed even if the
compression is enabled.'
* Current: A `Current` volume is a volume where data will be written
upon arrival (Primary Current) or HSM Policy Application (Secondary
Current)

[[volume-management-with-hsm-ng]]
Volume Management with HSM NG
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[creating-a-new-volume]]
Creating a new volume
^^^^^^^^^^^^^^^^^^^^^

[[from-the-administration-zimlet]]
From the Administration Zimlet
++++++++++++++++++++++++++++++

From the HSM NG tab of the Administration Zimlet:

* Click the appropriate `Add` in the `Volumes Managment` section
according to the type of volume you want to create.

* Select the store type, choosing between local mountpoint or S3 Bucket

* Enter the new volume's name.
* Enter a path for the new volume.
* Check the `Enable Compression` button if you wish to activate data
compression on the new volume.
* Select the Compression Thereshold.

* In case of S3 Bucket, it's possible to store multiple Bucket
information

* Press `OK` to create the new volume. Should the operation fail, a
Notification containing any related errors will be generated

[[from-the-cli]]
From the CLI
++++++++++++

To create a new volume through the CLI, the `doCreateVolume` command is
available:

....
Syntax:
   zxsuite hsm doCreateVolume {primary|secondary|index} {volume_name} {volume_path} [attr1 value1 [attr2 value2...

PARAMETER LIST

NAME                              TYPE               EXPECTED VALUES            DEFAULT
volume_type(M)                    Multiple choice    primary|secondary|index
volume_name(M)                    String
volume_path(M)                    Path
volume_compressed(O)              Boolean            true|false                 false
compression_threshold_bytes(O)    Long                                          4096

(M) == mandatory parameter, (O) == optional parameter

Usage example:

zxsuite hsm docreatevolume secondary `volume B` `/opt/zimbra/store_B/` volume_compressed true compression_threshold_bytes 4096
Creates a new secondary volume named `volume B` in /opt/zimbra/store_B/, with compression and compression threshold to 4096 bytes
....

[[editing-a-volume]]
Editing a volume
^^^^^^^^^^^^^^^^

[[from-the-administration-zimlet-1]]
From the Administration Zimlet
++++++++++++++++++++++++++++++

Simply select an existing volume and press the appropriate `Edit`
button.

[[from-the-cli-1]]
From the CLI
++++++++++++

To edit a volume through the CLI, the `doUpdateVolume` command is
available:

....
Syntax:
   zxsuite hsm doCreateVolume {primary|secondary|index} {volume_name} {volume_path} [attr1 value1 [attr2 value2...

PARAMETER LIST

NAME                              TYPE               EXPECTED VALUES            DEFAULT
volume_type(M)                    Multiple choice    primary|secondary|index
volume_name(M)                    String
volume_path(M)                    Path
volume_compressed(O)              Boolean            true|false                 false
compression_threshold_bytes(O)    Long                                          4096

(M) == mandatory parameter, (O) == optional parameter

Usage example:

zxsuite hsm docreatevolume secondary `volume B` `/opt/zimbra/store_B/` volume_compressed true compression_threshold_bytes 4096
Creates a new secondary volume named `volume B` in /opt/zimbra/store_B/, with compression and compression threshold to 4096 bytes
zimbra@test:~$ zxsuite hsm doUpdateVolume

command doUpdateVolume requires more parameters

Syntax:
   zxsuite hsm doUpdateVolume {volume_id} [attr1 value1 [attr2 value2...

PARAMETER LIST

NAME                        TYPE       EXPECTED VALUES    DEFAULT
volume_id(M)                Integer
volume_type(O)              String                        inherited_value
volume_name(O)              String                        inherited_value
volume_path(O)              Path                          inherited_value
current_volume(O)           Boolean    true|false         false
volume_compressed(O)        Boolean    true|false         false
compression_threshold(O)    Long                          4096

(M) == mandatory parameter, (O) == optional parameter

Usage example:

zxsuite hsm doupdatevolume 3 secondary `example volume` `/opt/zimbra/store_example/`
Sets name of volume 3 to `example volume`, make it secondary, and set its path to /opt/zimbra/store_example/
....

[[deleting-a-volume]]
Deleting a volume
^^^^^^^^^^^^^^^^^

[[from-the-administration-zimlet-2]]
From the Administration Zimlet
++++++++++++++++++++++++++++++

Select and existing volume and press the appropriate `Delete` button.
Remember that only *empty* volumes can be deleted.

[[from-the-cli-2]]
From the CLI
++++++++++++

To delete a volume through the CLI, the `doDeleteVolume` command is
available:

....
Syntax:
   zxsuite hsm doUpdateVolume {volume_id} [attr1 value1 [attr2 value2...

PARAMETER LIST

NAME                        TYPE       EXPECTED VALUES    DEFAULT
volume_id(M)                Integer
volume_type(O)              String                        inherited_value
volume_name(O)              String                        inherited_value
volume_path(O)              Path                          inherited_value
current_volume(O)           Boolean    true|false         false
volume_compressed(O)        Boolean    true|false         false
compression_threshold(O)    Long                          4096

(M) == mandatory parameter, (O) == optional parameter

Usage example:

zxsuite hsm doupdatevolume 3 secondary `example volume` `/opt/zimbra/store_example/`
Sets name of volume 3 to `example volume`, make it secondary, and set its path to /opt/zimbra/store_example/
zimbra@simone:~$ zxsuite hsm doDeleteVolume

command doDeleteVolume requires more parameters

Syntax:
   zxsuite hsm doDeleteVolume {volume_name}

PARAMETER LIST

NAME              TYPE
volume_name(M)    String

(M) == mandatory parameter, (O) == optional parameter

Usage example:

zxsuite hsm dodeletevolume hsm
Deletes volume with name hsm
....

[[policy-management]]
Policy Management
-----------------

[[what-is-a-policy]]
What is a Policy
~~~~~~~~~~~~~~~~

A HSM Policy is a set of rules that will be applied to define what items
will be moved from the Primary Store to the Secondary Store when the
`doMoveBlobs` operation of HSM NG is triggered, either manually or by
scheduling.

A Policy can consist of a single rule valid for all Item Types
(`Simple` policy) or multiple rules valid for one or more Item Types
(`Composite` policy). Also, an additional `sub-rule` can be defined
using Zimbra's
http://wiki.zimbra.com/wiki/Zimbra_Web_Client_Search_Tips[search
syntax].

[[policy-examples]]
Policy Examples
+++++++++++++++

Here you can find some Policy examples described in human readable
language. To see how to create this Policies in the HSM NG module, see
below.

* `Move all items older than 30 days`
* `Move emails older than 15 days and items of all other kinds older
than 30 days`
* `Move calendar items older than 15 days, briefcase items older than 20 days
and all emails in the "Archive" folder`

[[defining-a-policy]]
Defining a Policy
~~~~~~~~~~~~~~~~~

Policies can be defined both from the HSM NG tab of the Administration
Zimlet and from the CLI. You can specify a Zimbra Search in both cases.

[[from-the-administration-zimlet-3]]
From the Administration Zimlet
++++++++++++++++++++++++++++++

* Log into the Zimbra Administration Console.
* Click the `HSM NG` entry on the Administration Zimlet.

* Click the `Add` button in the Storage Management Policy section of the
page.

* Select the Item Types from the `Items to Move:` list.
* Enter the Item Age from the `Move Items older than:` box.
* *OPTIONAL*: Add a Zimbra Search in the `Addiditional Options` box.

* You can add multiple `lines` to narrow down your policy. Every `line`
will be evaluated and executed after the line before has been applied.

[[from-the-cli-3]]
From the CLI
++++++++++++

Two policy management commands are available il the CLI

* setHsmPolicy
* +setHsmPolicy

[[zxsuite-hsm-ng-sethsmpolicy-policy]]
zxsuite hsm setHsmPolicy \{policy}

This command resets the current policy and creates a new one as
specified by the _policy_ parameter.

The _policy_ parameter must be specified in the following syntax

`itemType1[,itemType2,itemtype3,etc]:query`

[[zxsuite-hsm-ng-sethsmpolicy-policy-1]]
zxsuite hsm +setHsmPolicy \{policy}

This command adds the query specified by the _policy_ parameter to the
current HSM Policy.

The _policy_ parameter must be specified in the following syntax

`itemType1[,itemType2,itemtype3,etc]:query`

[[secondary-volumes-on-amazon-s3]]
Secondary volumes on Amazon S3
------------------------------

[[hsm-ng-and-s3-buckets]]
HSM NG and S3 buckets
~~~~~~~~~~~~~~~~~~~~~

Starting from Network NG Modules 2.4.0, secondary volumes created with
HSM NG can now be hosted on S3 buckets, effectively moving the largest
part of your data to a secure and durable cloud storage.

[[s3-compatible-services]]
S3-compatible services
^^^^^^^^^^^^^^^^^^^^^^

While any storage service compatible with the Amazon S3 API should work
out of the box with HSM NG, Amazon S3 and DellEMC ECS are the only
officially supported platforms at the moment.

[[local-cache]]
Local Cache
^^^^^^^^^^^

This feature requires a local directory to be used for item caching,
which must be readable and writable by the `zimbra` user.

Such directory must be created manually and its path must be entrered in
the `HSM NG` section of the Administration Zimlet in the Zimbra
Administration Console.

WARNING: Failing to correctly set the cache directory will cause items
to be unretrievable, meaning that users will get a `No such BLOB` error
when trying to access any item stored on an S3 volume.

[[bucket-setup]]
Bucket setup
~~~~~~~~~~~~

HSM NG doesn't need any dedicated setting or configuration on the S3
side, so setting up a bucket for your volumes is pretty easy - creating
a dedicated user, bucket and access policy is not required but strongly
suggested as it's much easier to manage.

All you need to start storing your secondary volumes on S3 is:

* An S3 bucket. You need to know the bucket's name and region in order
to use it.
* A user's Access Key and Secret.
* A policy which grants the user full rights on your bucket.

[[s3-buckets]]
S3 Buckets
^^^^^^^^^^

Instead of adding the bucket's data each time you add a new secondary
volume, you can save it on the Zimbra Administration Console at
*Configure > Global Settings > S3 Buckets*.

[[creating-a-secondary-volume-on-s3]]
Creating a secondary volume on S3
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* Click on the `HSM NG` entry of the Administration Zimlet in the
Zimbra Administration Console.
* Under the `Secondary Volumes` list, click on `Add`

* Select `S3 bucket`

* Enter the volume's name and prefix, then either add a bucket's
information or load those from the ones saved in the Global Settings.
Define whether to use the Infrequent Access storage class and if so set
its size threshold.

* Define whether the new volume is set as Current or not and click
`Finish` to create the new volume.

[[amazon-s3-tips]]
Amazon S3 tips
~~~~~~~~~~~~~~

[[bucket]]
Bucket
^^^^^^

Storing your secondary Zimbra volumes on Amazon S3 doesn't have any
specific bucket requirements, albeit we suggest to create a dedicated
Bucket disabling Static Website Hosting for an easier management.

[[user]]
User
^^^^

In order to obtain an Access Key and the related Secret, a `Programmatic
Access` used is needed: we suggest to create a dedicated one in Amazon's
IAM Service for an easier management.

[[rights-management]]
Rights Management
^^^^^^^^^^^^^^^^^

In Amazon's IAM you can set access policies for your users. It's
mandatory that the user your Access Key and Secret belong to has a set
of appropriate rights both on the bucket itself and on its content -
granting full rights such as in the following example is suggested for
an easier management:

....
{
    `Version`: `[LATEST API VERSION]`,
    `Statement`: [
        {
            `Sid`: `[AUTOMATICALLY GENERATED]`,
            `Effect`: `Allow`,
            `Action`: [
                `s3:*`
            ],
            `Resource`: [
                `[BUCKET ARN]/*`,
                `[BUCKET ARN]`
            ]
        }
    ]
}
....

_WARNING - This is not a valid configuration policy. Don't copy and
paste it in your user's settings as it won't be validated._

If you only wish to grant minimal permissions, change the `Action`
section to:

....
"Action": [
                `s3:PutObject`,
                `s3:GetObject`,
                `s3:DeleteObject`,
                `s3:AbortMultipartUpload`
              ],
....

The bucket's ARN is expressed according to Amazon's standard naming
format: *arn:partition:service:region:account-id:resource* - for more
information abuout this topic please check Amazon's documentation.

[[bucket-paths-and-naming]]
Bucket paths and naming
^^^^^^^^^^^^^^^^^^^^^^^

Files are stored in a bucket according to a well-defined path, which can
be customized at will in order to make your bucket's contents easier to
understand even on multiserver environments with multiple secondary
volumes:

/*Bucket Name*/*Destination Path*/[*Volume Prefix*-]*serverID*/

The *Bucket Name* and *Destination Path* are not tied to the volume
itself, and there can be as many volumes under the same destination path
as you wish.

The *Volume Prefix*, on the other hand, is specific to each volume and
it's a quick way to differentiate and recognize different volumes within
the bucket.

[[infrequent-access-storage-class]]
Infrequent Access storage class
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

HSM NG is compatible with the `Amazon S3 Standard - Infrequent access`
storage class, and will set any file larger than the `Infrequent Access
Threshold` value to this storage class.

For more information about Infrequent Access please refer to the
https://aws.amazon.com/s3/storage-classes[official Amazon S3
Documentation].

[[item-deduplication]]
Item Deduplication
------------------

[[what-is-item-deduplication]]
What is Item Deduplication
~~~~~~~~~~~~~~~~~~~~~~~~~~

Item Deduplication is a technicque that allows to save disk space by
storing a single copy of an item and referencing it multiple times
instead of storing multiple copies of the same item and referencing each
copy only once.

This might seem a minor improvement, in theory, but in practical use can
make a huge difference.

[[item-deduplication-in-zimbra]]
Item Deduplication in Zimbra
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Item Deduplication is performed by Zimbra at the moment of storing a new
item in the

When a new item is being created its `message ID` is compared to a list
of cached items, and in case of a match a hardlink to the cached
message's BLOB is created instead of a whole new BLOB for the message.

The dedupe cache is managed in Zimbra 8 through the following config
attributes:

*zimbraPrefDedupeMessagesSentToSelf*

Used to set the deduplication behaviour for sent-to-self messages.

....
<attr id="144" name="zimbraPrefDedupeMessagesSentToSelf" type="enum" value="dedupeNone,secondCopyifOnToOrCC,dedupeAll" cardinality="single"
optionalIn="account,cos" flags="accountInherited,domainAdminModifiable">
  <defaultCOSValue>dedupeNone</defaultCOSValue>
  <desc>dedupeNone|secondCopyIfOnToOrCC|moveSentMessageToInbox|dedupeAll</desc>
</attr>
....

*zimbraMessageIdDedupeCacheSize*

Number of cached Message IDs.

....
<attr id="334" name="zimbraMessageIdDedupeCacheSize" type="integer" cardinality="single" optionalIn="globalConfig" min="0">
  <globalConfigValue>3000</globalConfigValue>
  <desc>
    Number of Message-Id header values to keep in the LMTP dedupe cache.
    Subsequent attempts to deliver a message with a matching Message-Id
    to the same mailbox will be ignored.  A value of 0 disables deduping.
  </desc>
</attr>
....

*zimbraPrefMessageIdDedupingEnabled*

Manage deduplication at Account or COS-level.

....
<attr id="1198" name="zimbraPrefMessageIdDedupingEnabled" type="boolean" cardinality="single" optionalIn="account,cos" flags="accountInherited"
 since="8.0.0">
  <defaultCOSValue>TRUE</defaultCOSValue>
  <desc>
    Account-level switch that enables message deduping.  See zimbraMessageIdDedupeCacheSize for more details.
  </desc>
</attr>
....

*zimbraMessageIdDedupeCacheTimeout*

Timeout for each entry in the dedupe cache.

....
<attr id="1340" name="zimbraMessageIdDedupeCacheTimeout" type="duration" cardinality="single" optionalIn="globalConfig" since="7.1.4">
  <globalConfigValue>0</globalConfigValue>
  <desc>
    Timeout for a Message-Id entry in the LMTP dedupe cache. A value of 0 indicates no timeout.
    zimbraMessageIdDedupeCacheSize limit is ignored when this is set to a non-zero value.
  </desc>
</attr>
....

(older Zimbra versions might use different attributes or lack some of
them)

[[item-deduplication-and-hsm-ng]]
Item Deduplication and HSM NG
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The HSM NG module features a `doDeduplicate` operation that parses a
target volume to find and deduplicate any duplicated item.

Doing so you will save even more disk space, as while Zimbra's automatic
deduplication is bound to a limited cache, HSM NG's deduplication will
also find and take care of multiple copies of the same email regardless
of any cache or timing.

Running the `doDeduplicate` operation is also highly suggested after a
migration or a large data import in order to optimize your storage
usage.

[[running-a-volume-deduplication]]
Running a Volume Deduplication
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

[[via-the-administration-zimlet]]
Via the Administration Zimlet
+++++++++++++++++++++++++++++

To run a volume deduplication via the Administration Zimlet simply click
on the `HSM NG` tab, select the volume you wish to deduplicate and press
the `Deduplicate` button:

[[via-the-cli]]
Via the CLI
+++++++++++

....
zimbra@mailserver:~$ zxsuite hsm doDeduplicate

command doDeduplicate requires more parameters

Syntax:
   zxsuite hsm doDeduplicate {volume_name} [attr1 value1 [attr2 value2...

PARAMETER LIST

NAME              TYPE           EXPECTED VALUES    DEFAULT
volume_name(M)    String[,..]
dry_run(O)        Boolean        true|false         false

(M) == mandatory parameter, (O) == optional parameter

Usage example:

zxsuite hsm dodeduplicate secondvolume
Starts a deduplication on volume secondvolume
....

To list all available volumes, you can use the _`zxsuite hsm
getAllVolumes`_ command.

[[dodeduplicate-stats]]
`doDeduplicate` stats
^^^^^^^^^^^^^^^^^^^^^

The `doDeduplicate` operation is a valid target for the `monitor`
command, meaning that you can watch the command's statistics while it's
running through the `zxsuite hsm monitor [operationID]` command.

_Sample Output_

....
Current Pass (Digest Prefix):  63/64
 Checked Mailboxes:             148/148
 Deduplicated/duplicated Blobs: 64868/137089
 Already Deduplicated Blobs:    71178
 Skipped Blobs:                 0
 Invalid Digests:               0
 Total Space Saved:             21.88 GB
....

* `Current Pass (Digest Prefix)` - The `doDeduplicate` command will
analyze the BLOBS in groups based on the first characted of their digest
(name).
* `Checked Mailboxes` - The number of mailboxes analyzed for the current
pass.
* `Deduplicated/duplicated Blobs` - Number of BLOBS deduplicated by the
current operation / Number of total duplicated items on the volume.
* `Already Deduplicated Blobs` - Number of deduplicated blobs on the
volume (duplicated blobs that have been deduplicated by a previous run).
* `Skipped Blobs` - BLOBs that have not been analyzed, usually because
of a read error or missing file.
* `Invalid Digests` - BLOBs with a bad digest (name different from the
actual digest of the file).
* `Total Space Saved` - Amount of disk space freed by the doDeduplicate
operation.

Looking at the sample output above we can see that:

* The operation is running the second to last pass on the last mailbox
* 137089 duplicated BLOBs have been found, 71178 of which have already
been deduplicated previously.
* The current operation deduplicated 64868 BLOBs, for a total disk space
saving of 21.88GB

[[advanced-volume-operations]]
Advanced Volume Operations
--------------------------

[[hsm-ng-more-than-meets-the-eye]]
HSM NG: More than meets the eye
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

While at first sight HSM NG might only seem a module strictly dedicated
to HSM, it also features some highly useful Volume-related tools that
are not directly related to HSM.

Due to the implicit risks in volume management, this tools are only
available through the CLI.

[[volume-operations-at-a-glance]]
Volume Operations at a glance
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The following volume operations are available:

*doCheckBlobs* - Perform BLOB coherency checks on one or more volumes.

*doDeduplicate* - Start Item Dedupliaction on a volume.

*doVolumeToVolumeMove* - Move all items from a Volume to another.

*getVolumeStats* - Display informations about a volume's size and number
of thereby contained items/blobs.

[[volume-operation-analysis]]
Volume operation analysis
~~~~~~~~~~~~~~~~~~~~~~~~~

[[docheckblobs]]
doCheckBlobs
^^^^^^^^^^^^

[[usage]]
Usage

....
zimbra@mail:~$ zxsuite hsm doCheckBlobs

command doCheckBlobs requires more parameters

Syntax:
   zxsuite hsm doCheckBlobs {start} [attr1 value1 [attr2 value2...

PARAMETER LIST

NAME                           TYPE            EXPECTED VALUES    DEFAULT
action(M)                      String          start
volume_ids(O)                  Integer[,..]    1,3
mailbox_ids(O)                 Integer[,..]    2,9,27
missing_blobs_crosscheck(O)    Boolean         true|false         true
traced(O)                      Boolean         true|false         false

(M) == mandatory parameter, (O) == optional parameter

Usage example:

Usage examples:
zxsuite hsm doCheckBlobs start
Perform a BLOB coherency check on all message volumes

zxsuite hsm doCheckBlobs start volume_ids 1,3
Perform a BLOB coherency check on volumes 1 and 3

zxsuite hsm doCheckBlobs start mailbox_ids 2,9,27
Perform a BLOB coherency check on mailboxes 2,9 and 27

zxsuite hsm doCheckBlobs start missing_blobs_crosscheck false
Perform a BLOB coherency check without checking on other volumes

zxsuite hsm doCheckBlobs start traced true
Perform a BLOB coherency check, logging even the correct checked items
....

[[description-and-tips]]
Description and Tips

The doCheckBlobs operation can be used to run BLOB coherency checks on
volumes and mailboxes. This can be useful when experiencing issues
related to broken or unviewable items, as such are often caused by
either the impossibility for Zimbra to find or access the BLOB file
related to an Item or an issue with the BLOB content itself.

Specifically, the following checks are made:

* DB-to-BLOB coherency: For every Item entry in Zimbra's DB, check
whether the appropriate BLOB file exists
* BLOB-to-DB coherency: For every BLOB file in a volume/mailbox, check
whether the appropriate DB data exists
* Filename coherency: Checks the coherency of each BLOB's filename with
its content (as BLOBs are named after their file's SHA hash)
* Size coherency: For every BLOB file in a volume/mailbox, checks
whether the BLOB file's size is coherent with the expected size (stored
in the DB)

[[dodeduplicate]]
doDeduplicate
^^^^^^^^^^^^^

[[usage-1]]
Usage

....
zimbra@mail:~$ zxsuite hsm doDeduplicate

command doDeduplicate requires more parameters

Syntax:
   zxsuite hsm doDeduplicate {volume_name} [attr1 value1 [attr2 value2...

PARAMETER LIST

NAME              TYPE           EXPECTED VALUES    DEFAULT
volume_name(M)    String[,..]
dry_run(O)        Boolean        true|false         false

(M) == mandatory parameter, (O) == optional parameter

Usage example:

zxsuite hsm dodeduplicate secondvolume
Starts a deduplication on volume secondvolume
....

[[dovolumetovolumemove]]
doVolumeToVolumeMove
^^^^^^^^^^^^^^^^^^^^

[[usage-2]]
Usage

....
zimbra@mail:~$ zxsuite hsm doVolumeToVolumeMove

command doVolumeToVolumeMove requires more parameters

Syntax:
   zxsuite hsm doVolumeToVolumeMove {source_volume_name} {destination_volume_name}

PARAMETER LIST

NAME                          TYPE
source_volume_name(M)         String
destination_volume_name(M)    String

(M) == mandatory parameter, (O) == optional parameter

Usage example:

zxsuite hsm doVolumeToVolumeMove sourceVolume destVolume
Moves the whole sourceVolume to destVolume
....

[[description-and-tips-2]]
Description and Tips

This command can prove itself highly useful in all those situations
where you need to stop using a volume, such as:

* Decommissioning old hardware - if you want to get rid of that old disk
in a physical server, just create new volumes on other/newer disks and
move your data there.
* Fixing `little mistakes` - Toying around with loop devices or new
mount options made you create a new volume in the wrong place? Move the
data to another volume! _Nobody saw anything, I swear!_
* Centralize volumes - are you just done redesigning your storage
infrastructure or you just finally decided to tidy up your Zimbra
volumes? With this command you can centralize and move volumes as you
please.

[[getvolumestats]]
getVolumeStats
^^^^^^^^^^^^^^

[[usage-3]]
Usage

....
zimbra@mail:~$ zxsuite hsm getVolumeStats

command getVolumeStats requires more parameters

Syntax:
   zxsuite hsm getVolumeStats {volume_id} [attr1 value1 [attr2 value2...

PARAMETER LIST

NAME                   TYPE       EXPECTED VALUES    DEFAULT
volume_id(M)           Integer
show_volume_size(O)    Boolean    true|false         false
show_blob_num(O)       Boolean    true|false         false

(M) == mandatory parameter, (O) == optional parameter

Usage example:

**BE CAFERUL** show_volume_size and show_blob_num options are IO intensive and thus disabled by default

zxsuite hsm getVolumeStats 2
Shows stats for the volume with ID equal to 2
....

[[description-and-tips-3]]
Description and Tips

This command provides the following informations about a volume:

[cols=",",options="header",]
|=======================================================================
|name |description
|id |The ID of the volume

|name |The Name of the volume

|path |The Path of the volume

|compressed |Compression enabled/disabled

|threshold |Compression threshold (in bytes)

|lastMoveOutcome |Exit status of the latest doMoveBlobs operation

|lastMoveTimestamp |End timestamp of the latest doMoveBlobs operation

|lastMoveDuration |Duration of the last doMoveBlobs operation

|lastItemMovedCount |Number of items moved to the current secondary
volume during the latest doMoveBlobs operation

|bytesSaved |Total amount of disk space freed up thanks to deduplication
and compression

|bytesSavedLast |Amount of disk space freed up thanks to deduplication
and compression during the latest doMoveBlobs operation
|=======================================================================

The `show_volume_size` and `show_blob_num` options will add the
following data to the output:

[cols=",,",options="header",]
|=================================================================
|option |name |description
|show_volume_size |totSize |Total disk space used up by the volume
|show_blob_num |blobNumber |Number of BLOB files in the volume
|=================================================================

[moving-mailboxes-between-mailstores]
Moving mailboxes between mailstores
-----------------------------------
The `doMailboxMove` command is intended to move a single mailbox from a server to another one or all accounts from a given domain on current server to a
destination host.

[doMailboxMove-syntax]
doMailboxMove Syntax
^^^^^^^^^^^^^^^^^^^^
....
yntax:
   zxsuite hsm doMailboxMove {an account name: john@example.com or a domain name: example.com} {destinationHost} [attr1 value1 [attr2 value2...]]

PARAMETER LIST

NAME                  TYPE               EXPECTED VALUES                                                          DEFAULT
name(M)               String             maybe an account name: john@example.com or a domain name: example.com
destinationHost(M)    String
sourceHost(O)         String             used if a domain name is specified into name parameter
stage(O)              Multiple choice    blobs|db|chat_db|ldap|backup|reindex|delete|all                          all
compress(O)           Boolean            true|false                                                               true
checkDigest(O)        Boolean            if false skip digest calculation and check                               true
overwrite(O)          Boolean            true|false                                                               false
threads(O)            Integer                                                                                     10
hsm(O)                Boolean            true|false                                                               true
notifications(O)      Email Address

(M) == mandatory parameter, (O) == optional parameter

Usage example:

zxsuite HSM NG domailboxmove john@example.com mail2.example.com
Move mailbox for account john@example.com to mail2.example.com host
....
Parameters
^^^^^^^^^^
* _sourceHost_: Used only if a domain name is specified into name parameter, act like the command was issued from this host.
* _stage_: It's possible to submit only a single stage at time, just for test purpose or to not reissue a previously completed stage.
* _compress_: If true, blobs will be compressed just before being sent through the network.
* _checkDigest_: If true, a digest check will be made for each blob (digest is taken from the item's db entry).
* _overwrite_: If false, and digest check is correct, blob files will not be overwritten.
* _threads_: number of threads used on heavy stages.
* _hsm_: If true an HSM operation will be submitted after mailbox successfully moved.

[doMailboxMove-details]
doMailboxMove Details
^^^^^^^^^^^^^^^^^^^^^
* When moving a domain, each account from current server is enumerated and moved sequentially.
* Mailbox is set into maintenance mode when it's moved, and will be placed into original state after all emails are moved (after the ldap stage).
* Operation is stopped if 5% or more write errors are encountered on items being moved. Pay attention that the current mailbox
   may remains in maintenance mode.
* Single-mailbox moves will not start if destination server has not enough space available or user just belongs
   to destination host.
* All data is moved at low-level and will not be changed except some small things like mailbox id.
* The operation is made up of 7 stages: blobs|db|chat_db|ldap|backup|reindex|delete. For each mailbox:
    ** blobs:   all blobs are copied from source server to destination one.
    ** db:      all database entries are copied form source server to destination one.
    ** chat_db: all chat db information are copied from source server to destination one.
    ** ldap:    zimbraMailHost ldap attribute is updated and all account caches are flushed.
    ** backup:  all backup entries are copied from source server to destination one.
    ** reindex: start a mailbox reindex.
    ** delete:  all blobs and db entries are deleted from source server, backup items are also marked as deleted.
* All of the stages are executed sequentially. If a single stage is specified, mailbox is parked in maintenance mode though the entire operation.
   On success mailbox will be placed into original state.
* Initially all blob items will be stored into destination server primary volume.
* On the reindex stage's completion an HSM new operation is submitted to destination server, if not specified otherwise.
* All volumes' compression options are taken in care.
* The MailboxMove operation can be executed if and only if no others operations are running on the source server.
* The HSM option applies current HSM policies. It's runs after each mailbox is successfully moved, on any run new items will be moved.

[[hsm-ng-attachment-indexing]]
HSM NG Attachment Indexing
--------------------------

[[how-indexing-works]]
How indexing works
~~~~~~~~~~~~~~~~~~
A new Indexing Engine has been added to HSM NG to index attachment contents.

It works together with Zimbra's default engine: the main Zimbra indexing
process analyzes the content of an item, splitting it into several parts
based on the MIME parts of the object, then handles the indexing of
`known` contents - plaintext - and passes the datastream on to the
HSM NG handlers for all other content.

It includes an indexing cache, that speeds up the indexing process of
any content that has already been analyzed. Datastreams over 10Kb are
cached by default and the cache hold 10000 entries, while smaller
datastreams are not cached as the cache benefits only apply to large
datastreams.

[[indexed-formats]]
Indexed formats
~~~~~~~~~~~~~~~

[[web]]
Web
+++

[cols=",,",options="header",]
|=============================================================
|Extension |Parser |Content-type
|``asp'' |``HtmlParser'' |//application/x-asp
|``htm'' |``HtmlParser'' |//application/xhtml+xml
|``html'' |``HtmlParser'' |//application/xhtml+xml | text/html
|``shtml'' |``HtmlParser'' |//application/xhtml+xml
|``xhtml'' |``HtmlParser'' |//application/xhtml+xml
|=============================================================

[[documents]]
Documents
+++++++++

[cols=",,",options="header",]
|=======================================================================
|Extension |Parser |Content-type
|``rtf'' |``RTFParser'' |//application/rtf

|``pdf'' |`PDFParser` |//application/pdf

|``pub'' |`OfficeParser` |//application/x-mspublisher

|``xls'' |`OfficeParser` |//application/vnd.ms-excel

|``xlt'' |`OfficeParser` |//application/vnd.ms-excel

|``xlw'' |`OfficeParser` |//application/vnd.ms-excel

|``ppt'' |`OfficeParser` |//application/vnd.ms-powerpoint

|``pps'' |`OfficeParser` |//application/vnd.ms-powerpoint

|``mpp'' |`OfficeParser` |//application/vnd.ms-project

|``doc'' |`OfficeParser` |//application/msword

|``dot'' |`OfficeParser` |//application/msword

|``msg'' |`OfficeParser` |//application/vnd.ms-outlook

|``vsd'' |`OfficeParser` |//application/vnd.visio

|``vst'' |`OfficeParser` |//application/vnd.visio

|``vss'' |`OfficeParser` |//application/vnd.visio

|``vsw'' |`OfficeParser` |//application/vnd.visio

|``xlsm'' |`OOXMLParser`
|//application/vnd.ms-excel.sheet.macroenabled.12

|``pptm'' |`OOXMLParser`
|//application/vnd.ms-powerpoint.presentation.macroenabled.12

|``xltx'' |`OOXMLParser`
|//application/vnd.openxmlformats-officedocument.spreadsheetml.template

|``docx'' |`OOXMLParser`
|//application/vnd.openxmlformats-officedocument.wordprocessingml.document

|``potx'' |`OOXMLParser`
|//application/vnd.openxmlformats-officedocument.presentationml.template

|``xlsx'' |`OOXMLParser`
|//application/vnd.openxmlformats-officedocument.spreadsheetml.sheet

|``pptx'' |`OOXMLParser`
|//application/vnd.openxmlformats-officedocument.presentationml.presentation

|``xlam'' |`OOXMLParser`
|//application/vnd.ms-excel.addin.macroenabled.12

|``docm'' |`OOXMLParser`
|//application/vnd.ms-word.document.macroenabled.12

|``xltm'' |`OOXMLParser`
|//application/vnd.ms-excel.template.macroenabled.12

|``dotx'' |`OOXMLParser`
|//application/vnd.openxmlformats-officedocument.wordprocessingml.template

|``ppsm'' |`OOXMLParser`
|//application/vnd.ms-powerpoint.slideshow.macroenabled.12

|``ppam'' |`OOXMLParser`
|//application/vnd.ms-powerpoint.addin.macroenabled.12

|``dotm'' |`OOXMLParser`
|//application/vnd.ms-word.template.macroenabled.12

|``ppsx'' |`OOXMLParser`
|//application/vnd.openxmlformats-officedocument.presentationml.slideshow

|``odt'' |`OpenDocumentParser`
|//application/vnd.oasis.opendocument.text

|``ods'' |`OpenDocumentParser`
|//application/vnd.oasis.opendocument.spreadsheet

|``odp'' |`OpenDocumentParser`
|//application/vnd.oasis.opendocument.presentation

|``odg'' |`OpenDocumentParser`
|//application/vnd.oasis.opendocument.graphics

|``odc'' |`OpenDocumentParser`
|//application/vnd.oasis.opendocument.chart

|``odf'' |`OpenDocumentParser`
|//application/vnd.oasis.opendocument.formula

|``odi'' |`OpenDocumentParser`
|//application/vnd.oasis.opendocument.image

|``odm'' |`OpenDocumentParser`
|//application/vnd.oasis.opendocument.text-master

|``ott'' |`OpenDocumentParser`
|//application/vnd.oasis.opendocument.text-template

|``ots'' |`OpenDocumentParser`
|//application/vnd.oasis.opendocument.spreadsheet-template

|``otp'' |`OpenDocumentParser`
|//application/vnd.oasis.opendocument.presentation-template

|``otg'' |`OpenDocumentParser`
|//application/vnd.oasis.opendocument.graphics-template

|``otc'' |`OpenDocumentParser`
|//application/vnd.oasis.opendocument.chart-template

|``otf'' |`OpenDocumentParser`
|//application/vnd.oasis.opendocument.formula-template

|``oti'' |`OpenDocumentParser`
|//application/vnd.oasis.opendocument.image-template

|``oth'' |`OpenDocumentParser`
|//application/vnd.oasis.opendocument.text-web

|``sxw'' |`OpenDocumentParser` |//application/vnd.sun.xml.writer
|=======================================================================

[[packages-and-archives]]
Packages and Archives
+++++++++++++++++++++

[cols=",,",options="header",]
|======================================================
|Extension |Parser |Content-Type
|``z'' |`CompressorParser` |//application/x-compress
|``bz'' |`CompressorParser` |//application/x-bzip
|``boz'' |`CompressorParser` |//application/x-bzip2
|``bz2'' |`CompressorParser` |//application/x-bzip2
|``gz'' |`CompressorParser` |//application/gzip
|``gz'' |`CompressorParser` |application/x-gzip
|``gzip'' |`CompressorParser` |//application/x-gzip
|``xz'' |`CompressorParser` |//application/x-xz
|``tar'' |`PackageParser` |//application/x-tar
|``jar'' |`PackageParser` |//application/java-archive
|``7z'' |`PackageParser` |//application/x-7z-compressed
|``cpio'' |`PackageParser` |//application/x-cpio
|``zip'' |`PackageParser` |//application/zip
|``rar'' |`RarParser` |//application/x-rar-compressed
|``txt'' |`TXTParser` |//text/plain
|======================================================

[[parser-controls]]
Parser Controls
~~~~~~~~~~~~~~~

Parsers can be turned on or off by changing the related value to `true`
or `false` via the `zxsuite config` CLI command.

[cols=",",options="header",]
|==================================================================
|Attribute |Parsers
|pdfParsingEnabled |PDFParser
|odfParsingEnabled |OpenDocumentParser
|archivesParsingEnabled |CompressorParser, PackageParser, RarParser
|microsoftParsingEnabled |OfficeParser, OOXMLParser, OldExcelParser
|rtfParsingEnabled |RTFParser
|==================================================================

e.g. to disable PDF parsing run:
`zxsuite config server set server.domain.com attribute pdfParsingEnabled value false`

By default, all parsers are active.
